import subprocess
import sys
import os
import json


class StreamingService:
    def __init__(self, file_manager):
        self.file_manager = file_manager

    def stream_generation(self, system_prompt, user_message, thinking_callback=None, text_callback=None):
        """
        Wrapper around script_1_gen.py using subprocess for process isolation.

        Note: thinking_callback and text_callback parameters are kept for backward compatibility
        but are not used in subprocess mode. Real-time streaming is not available.

        Returns:
            tuple: (json_data_dict, cost_data_dict)

        Raises:
            ValueError: If response is empty or invalid JSON
            RuntimeError: If subprocess fails or unexpected error occurs
        """
        try:
            # Get session directory path
            session_dir = os.path.dirname(self.file_manager.get_path('dummy'))

            # Calculate absolute path to script (project root)
            project_root = os.path.dirname(os.path.dirname(session_dir))
            script_path = os.path.join(project_root, 'script_1_gen.py')

            # Ensure paths are absolute (defensive)
            script_path = os.path.abspath(script_path)
            session_dir = os.path.abspath(session_dir)

            # Write input file for script
            prompt_content = f"{system_prompt}\n---SEP---\n{user_message}"
            prompt_path = os.path.join(session_dir, 'prompt.txt')
            with open(prompt_path, 'w') as f:
                f.write(prompt_content)

            # Run subprocess
            try:
                subprocess.run(
                    [sys.executable, script_path],
                    cwd=session_dir,
                    check=True,
                    timeout=600,
                    capture_output=True,
                    text=True
                )
            except subprocess.TimeoutExpired as e:
                raise RuntimeError(
                    f"FSM generation timed out after 600 seconds. "
                    f"This may indicate a very large prompt or API issues."
                ) from e
            except subprocess.CalledProcessError as e:
                raise RuntimeError(
                    f"FSM generation subprocess failed with exit code {e.returncode}.\n"
                    f"stderr: {e.stderr}\n"
                    f"stdout: {e.stdout}"
                ) from e

            # Read outputs from session directory
            output_json_path = os.path.join(session_dir, 'output.json')
            cost_metrics_path = os.path.join(session_dir, 'cost_metrics.json')

            # Load and parse output.json
            try:
                with open(output_json_path, 'r') as f:
                    final_text = f.read()
                json_data = json.loads(final_text)
            except FileNotFoundError:
                raise ValueError(
                    "Script did not generate output.json. "
                    "The FSM generation may have failed silently."
                )
            except json.JSONDecodeError as e:
                # Save failed response for inspection
                error_msg = (
                    f"Failed to parse JSON from Claude's response.\n"
                    f"Error: {str(e)}\n"
                    f"Response length: {len(final_text)} chars\n"
                    f"Response preview:\n{final_text[:500]}..."
                )
                self.file_manager.save_text(error_msg, 'parsing_error.txt')
                self.file_manager.save_text(final_text, 'raw_response.txt')
                raise ValueError(error_msg) from e

            # Load cost metrics
            try:
                with open(cost_metrics_path, 'r') as f:
                    cost_data = json.load(f)
            except FileNotFoundError:
                raise ValueError(
                    "Script did not generate cost_metrics.json. "
                    "Cost tracking may have failed."
                )

            # Note: thinking.txt is not generated by script in CLI mode
            # It will not be available in subprocess mode

            return json_data, cost_data

        except ValueError as e:
            # Re-raise validation errors
            raise
        except RuntimeError as e:
            # Re-raise subprocess errors
            raise
        except Exception as e:
            # Catch any other unexpected errors
            raise RuntimeError(f"Unexpected error during FSM generation: {str(e)}") from e
